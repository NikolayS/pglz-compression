From 7e578ccbe70253f94ab59f23be6ba866807a0137 Mon Sep 17 00:00:00 2001
From: Nikolay Samokhvalov <nik@postgres.ai>
Date: Wed, 18 Feb 2026 18:47:25 +0000
Subject: [PATCH 0/5] pglz: five performance and correctness improvements
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This series improves src/common/pg_lzcompress.c in five incremental steps,
each independently reviewable and bisect-safe.  All patches target the
compressor only; the decompressor is unchanged.  Every patch is verified
to pass make check (239/239 regression tests) on the full PostgreSQL tree.

== Motivation ==

The pglz compressor's hot path — match finding and history management —
has accumulated several inefficiencies since its original 1999 design:

1. Macro-based helper functions with UBSan violations (signed left shifts)
2. 32-byte PGLZ_HistEntry on 64-bit platforms (2× cache pressure vs. needed)
3. Doubly-linked list has an O(1) unlink that costs an extra prev pointer
4. Byte-by-byte match comparison with no early reject for non-matching candidates
5. Polynomial hash with poor avalanche on structured data (SQL, JSON, text)

== Series Overview ==

Patch 1: macros → static inline functions
  Convert pglz_hist_idx, pglz_hist_add, pglz_out_ctrl, pglz_out_literal,
  pglz_out_tag to static inline functions.  Eliminates multiple-evaluation
  hazards and UBSan unsigned-char violations.  Bit-identical output.

Patch 2: PGLZ_HistEntry 32→16 bytes via uint16 indexes
  Replace pointer-based doubly-linked list with index-based (int16).
  Sentinel: -1 (PGLZ_INVALID_ENTRY) instead of NULL.  hist_entries[]
  working set drops from ~128 KiB to ~64 KiB — fits in L1+L2 cache.
  Compile-time assertions guard against future constant changes.

Patch 3: singly-linked list with predecessor-scan unlink
  Remove the prev index field, saving 2 bytes per entry.  Unlink via
  pglz_hist_unlink() which scans forward from chain head.  CRITICAL:
  pglz_hist_unlink() has NO chain-length limit — abandoning mid-scan
  corrupts the old chain.  pglz_find_match() uses PGLZ_MAX_CHAIN=256
  as read-only defense-in-depth (safe: missed match ≠ corruption).

Patch 4: 4-byte memcmp fast-reject; dend-3 main loop; byte-by-byte tail
  Add memcmp(ip, hp, 4) fast-reject in pglz_find_match().  Main loop
  runs while (dp < dend-3); last 0-3 bytes handled byte-by-byte as
  literals (emitted via the same pglz_out_literal + hist_add path as the main loop,
  just without calling pglz_find_match())

Patch 5: Fibonacci multiply-shift hash
  Replace ((s[0]<<6)^(s[1]<<4)^(s[2]<<2)^s[3]) with
  (read32_le(s) * 2654435761u) >> 19.  The Knuth multiplicative constant
  (golden ratio × 2^32) gives uniform bucket distribution for ASCII data
  where the polynomial hash produces systematic collisions.  Reduces
  average chain length from ~15-30 to ~1 on real-world SQL/text inputs.

== Testing ==

make check: 239/239 tests pass on each individual patch.
Benchmarks (compression throughput, ratio): deferred to beta agent.

Nikolay Samokhvalov (5):
  pglz: replace macros with static inline functions
  pglz: shrink PGLZ_HistEntry from 32 to 16 bytes using uint16 indexes
  pglz: convert to singly-linked list with predecessor-scan unlink
  pglz: add 4-byte memcmp fast-reject in match finding; split tail
    handling
  pglz: replace polynomial hash with Fibonacci multiply-shift hash

 src/common/pg_lzcompress.c | 449 ++++++++++++++++++++++++++-----------
 1 file changed, 320 insertions(+), 129 deletions(-)

-- 
2.43.0
