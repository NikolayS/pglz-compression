From b17be67987fb10d3e240d9f5649d07a27ff58319 Mon Sep 17 00:00:00 2001
From: Nikolay Samokhvalov <nik@postgres.ai>
Date: Wed, 18 Feb 2026 18:45:09 +0000
Subject: [PATCH 4/5] pglz: add 4-byte memcmp fast-reject in match finding;
 split tail handling

Two related optimizations to pglz_compress():

1. 4-byte fast-reject in pglz_find_match():
   The original inner loop started comparing byte-by-byte from offset 0.
   For most history candidates the match fails within the first 4 bytes.
   Replace the initial byte-by-byte loop with a single memcmp(ip, hp, 4)
   call.  GCC/Clang optimize memcmp(a, b, 4) into a single 4-byte load
   and compare on x86-64, so this costs one branch vs. up to 4 before.
   Only if the 4-byte prefix matches do we proceed to extend byte-by-byte.

   pglz_find_match() gains a 'source' parameter for debug assertions that
   verify hp >= source (valid backward reference) and hp+4 <= end (safe
   4-byte read).

2. Split main loop / tail in pglz_compress():
   To guarantee pglz_find_match() can always safely read 4 bytes at both
   ip (current position) and hp (history), the main loop now runs only
   while (dp < dend - 3).  The last 0-3 bytes, which cannot satisfy the
   4-byte read requirement, are processed byte-by-byte in a separate tail
   loop that emits only literals.  This is correct because a 3-byte match
   saves exactly 0 bytes vs. 3 literals in the worst case, and the hash
   function already uses 4 bytes so near-end matches are poorly hashed
   anyway.

The combination eliminates the first 3 iterations of the inner comparison
loop for every history candidate that fails the 4-byte check, which is the
common case for dissimilar data.

make check: 239/239 tests pass
---
 src/common/pg_lzcompress.c | 108 +++++++++++++++++++++++++++++--------
 1 file changed, 85 insertions(+), 23 deletions(-)

diff --git a/src/common/pg_lzcompress.c b/src/common/pg_lzcompress.c
index b340ab8..85df871 100644
--- a/src/common/pg_lzcompress.c
+++ b/src/common/pg_lzcompress.c
@@ -476,11 +476,28 @@ pglz_out_tag(unsigned char **ctrlp, unsigned char *ctrlb,
  *		Lookup the history table if the actual input stream matches
  *		another sequence of characters, starting somewhere earlier
  *		in the input buffer.
+ *
+ * The caller must ensure (end - input) >= 4.  This allows us to use a
+ * 4-byte memcmp() as a fast-reject filter: if the first 4 bytes don't
+ * match, skip immediately to the next history entry.  Modern compilers
+ * (GCC 7.1+, Clang) optimize memcmp(a, b, 4) == 0 into a single 4-byte
+ * load and compare â€” no function call overhead.
+ *
+ * This sacrifices rare 3-byte matches that differ in the 4th byte,
+ * for consistent speed improvement.  The ratio impact is negligible.
+ *
+ * Boundary proof for hp (the history pointer):
+ *   - hp was a previous position in the input buffer, so hp >= source
+ *     and hp < input.
+ *   - The caller guarantees input <= end - 4, and hp < input, therefore
+ *     hp <= input - 1 <= end - 5, so hp + 4 <= end - 1 < end.
+ *   - The 4-byte memcmp at hp is safe.
  * ----------
  */
 static inline int
 pglz_find_match(int16 *hstart, const char *input, const char *end,
-				int *lenp, int *offp, int good_match, int good_drop, int mask)
+				int *lenp, int *offp, int good_match, int good_drop,
+				int mask, const char *source)
 {
 	int16		hentno;
 	int32		len = 0;
@@ -507,31 +524,48 @@ pglz_find_match(int16 *hstart, const char *input, const char *end,
 			break;
 
 		/*
-		 * Determine length of match. A better match must be larger than the
-		 * best so far. And if we already have a match of 16 or more bytes,
-		 * it's worth the call overhead to use memcmp() to check if this match
-		 * is equal for the same size. After that we must fallback to
-		 * character by character comparison to know the exact position where
-		 * the diff occurred.
+		 * Boundary assertions (debug builds only).
+		 * hp >= source: hp is a previous input position, always >= buffer start.
+		 * hp < input: hp must precede current position (backward reference only).
+		 * hp + 4 <= end: the caller guarantees input <= end - 4, and
+		 *   hp < input, so hp + 4 <= input - 1 + 4 <= end - 1 < end + 1.
+		 *   Actually hp + 4 <= end strictly since hp <= end - 5.
+		 */
+#ifdef USE_ASSERT_CHECKING
+		Assert(hp >= source && hp < ip);
+		Assert(hp + 4 <= end);
+#endif
+
+		/*
+		 * Use 4-byte memcmp as a fast-reject filter.  If the first 4 bytes
+		 * don't match, skip immediately.  This eliminates the first 3
+		 * iterations of the inner loop for every candidate.
 		 */
-		thislen = 0;
-		if (len >= 16)
+		if (memcmp(ip, hp, 4) == 0)
 		{
-			if (memcmp(ip, hp, len) == 0)
+			thislen = 4;
+			ip += 4;
+			hp += 4;
+
+			/*
+			 * If we already have a match of 16+ bytes, use memcmp to
+			 * quickly check if this match is at least as long.
+			 */
+			if (len >= 16 && thislen < len)
 			{
-				thislen = len;
-				ip += len;
-				hp += len;
-				while (ip < end && *ip == *hp && thislen < PGLZ_MAX_MATCH)
+				if (memcmp(ip, hp, len - 4) == 0)
+				{
+					thislen = len;
+					ip = input + len;
+					hp = hent->pos + len;
+				}
+				else
 				{
-					thislen++;
-					ip++;
-					hp++;
+					goto next_entry;
 				}
 			}
-		}
-		else
-		{
+
+			/* Extend match byte-by-byte */
 			while (ip < end && *ip == *hp && thislen < PGLZ_MAX_MATCH)
 			{
 				thislen++;
@@ -539,6 +573,10 @@ pglz_find_match(int16 *hstart, const char *input, const char *end,
 				hp++;
 			}
 		}
+		else
+		{
+			goto next_entry;
+		}
 
 		/*
 		 * Remember this match as the best (if it is)
@@ -549,6 +587,7 @@ pglz_find_match(int16 *hstart, const char *input, const char *end,
 			off = thisoff;
 		}
 
+next_entry:
 		/*
 		 * Advance to the next history entry
 		 */
@@ -707,8 +746,12 @@ pglz_compress(const char *source, int32 slen, char *dest,
 
 	/*
 	 * Compress the source directly into the output buffer.
+	 *
+	 * The main loop processes bytes while at least 4 bytes remain.  This
+	 * guarantees the 4-byte memcmp in pglz_find_match is safe.  The last
+	 * 1-3 bytes are handled as literals in the tail loop below.
 	 */
-	while (dp < dend)
+	while (dp < dend - 3)
 	{
 		/*
 		 * If we already exceeded the maximum result size, fail.
@@ -730,10 +773,13 @@ pglz_compress(const char *source, int32 slen, char *dest,
 			return -1;
 
 		/*
-		 * Try to find a match in the history
+		 * Try to find a match in the history.  pglz_find_match uses a
+		 * 4-byte memcmp fast-reject, so the caller guarantees at least
+		 * 4 bytes remain (ensured by the loop condition above).
 		 */
 		if (pglz_find_match(hist_start, dp, dend, &match_len,
-							&match_off, good_match, good_drop, mask))
+							&match_off, good_match, good_drop, mask,
+							source))
 		{
 			/*
 			 * Create the tag and add history entries for all matched
@@ -762,6 +808,22 @@ pglz_compress(const char *source, int32 slen, char *dest,
 		}
 	}
 
+	/*
+	 * Tail: emit the last 0-3 bytes as literals.  We can't use the 4-byte
+	 * memcmp fast path here.
+	 */
+	while (dp < dend)
+	{
+		if (bp - bstart >= result_max)
+			return -1;
+
+		pglz_out_literal(&ctrlp, &ctrlb, &ctrl, &bp, *dp);
+		pglz_hist_add(hist_start, hist_entries,
+					  &hist_next, &hist_recycle,
+					  dp, dend, mask);
+		dp++;
+	}
+
 	/*
 	 * Write out the last control byte and check that we haven't overrun the
 	 * output size allowed by the strategy.
-- 
2.43.0

